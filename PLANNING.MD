# Planificaci√≥n General del Proyecto: Agenda Glam

## 1. Visi√≥n General del Proyecto: Agenda Glam

**Prop√≥sito y Alcance:**
Agenda Glam es una plataforma innovadora dise√±ada para revolucionar la gesti√≥n de servicios de est√©tica dirigidos al p√∫blico masculino en Uruguay. El proyecto busca simplificar el proceso de reserva de citas para los clientes finales y, al mismo tiempo, ofrecer herramientas de gesti√≥n comercial robustas y eficientes para los proveedores de servicios (negocios de est√©tica, barber√≠as, etc.). El objetivo es desarrollar la aplicaci√≥n completa con todas sus funcionalidades previstas.

**P√∫blico Objetivo:**
El proyecto se enfoca en dos grupos de usuarios principales:
1.  **Clientes:** Hombres en Uruguay que buscan descubrir, comparar y reservar servicios de est√©tica de manera f√°cil y r√°pida.
2.  **Proveedores de Servicios:** Due√±os de negocios y empleados del sector de la est√©tica masculina que necesitan una herramienta para gestionar sus agendas, servicios, clientes y personal.

**Funcionalidades Clave (Aplicaci√≥n Completa):**
*   **Para Clientes:**
    *   B√∫squeda y descubrimiento de proveedores de servicios.
    *   Visualizaci√≥n de perfiles de negocios, servicios ofrecidos, precios y disponibilidad.
    *   Reserva y gesti√≥n de citas online.
    *   Recordatorios de citas.
    *   Historial de servicios.
    *   Sistema de calificaciones y rese√±as.
*   **Para Proveedores de Servicios:**
    *   Gesti√≥n de agenda y calendario de citas (multi-empleado si es necesario).
    *   Configuraci√≥n de servicios, precios, duraciones y horarios de atenci√≥n.
    *   Gesti√≥n de perfiles de empleados con roles y permisos.
    *   Base de datos de clientes con historial.
    *   Notificaciones y confirmaciones de citas.
    *   Herramientas de marketing: promociones y cupones.
    *   Reportes y estad√≠sticas de rendimiento del negocio.

**Arquitectura de Alto Nivel:**
Agenda Glam se desarrollar√° siguiendo los principios de la **Arquitectura Limpia**, promoviendo una clara separaci√≥n de responsabilidades entre las siguientes capas:
1.  **Capa de Presentaci√≥n (UI):** Responsable de la interfaz de usuario y la interacci√≥n con el usuario. Construida con Flutter.
2.  **Capa de Dominio (L√≥gica de Negocio):** Contiene las reglas de negocio, entidades y casos de uso de la aplicaci√≥n. Independiente de frameworks espec√≠ficos.
3.  **Capa de Datos:** Encargada de la persistencia y obtenci√≥n de datos, interactuando con fuentes externas como la base de datos y servicios de red.

**Pila Tecnol√≥gica Principal:**
*   **Frontend (Aplicaci√≥n M√≥vil):** Flutter (Framework), Dart (Lenguaje de programaci√≥n). Inicialmente se priorizar√° la aplicaci√≥n m√≥vil.
*   **Backend y Base de Datos:** **Firebase** (BaaS - Backend as a Service). Esto incluye:
    *   **Firebase Authentication** para la autenticaci√≥n de usuarios.
    *   **Cloud Firestore** como base de datos NoSQL.
    *   **Firebase Storage** para im√°genes de perfil, logos de negocios, y potencialmente fotos de trabajos. Se gestionar√° la privacidad seg√∫n corresponda.
    *   **Cloud Functions for Firebase** para l√≥gica de backend que no deba residir en el cliente (ej. notificaciones complejas, c√°lculos intensivos). Se recomienda un uso inicial moderado.
*   **Gesti√≥n de Estado (Flutter):** BLoC (Business Logic Component) / Cubit.
*   **Pruebas:** Framework de pruebas de Flutter (para unitarias, widgets e integraci√≥n).
*   **Control de Versiones:** Git (con una plataforma como GitHub, GitLab o Bitbucket).
*   **Contenerizaci√≥n (Opcional):** Docker, para estandarizar entornos de desarrollo/CI o para futuros microservicios.
*   **Seguridad:** Se utilizar√°n las reglas de seguridad de Firestore y las configuraciones de Firebase Authentication para asegurar la correcta segregaci√≥n y acceso a los datos (cuando se implemente el backend).

## 2. Proceso Completo de Codificaci√≥n

Esta gu√≠a describe un proceso repetible y estructurado para crear software de calidad de producci√≥n para Agenda Glam.

### 2.1. üîë Reglas de Oro

Estos son los principios generales que gu√≠an el uso eficiente y eficaz de las herramientas. Los implementaremos mediante reglas globales y nuestra gu√≠a durante todo el proceso:

*   Utilice archivos markdown para administrar el proyecto (`README.MD`, `PLANNING.MD` (este archivo), y archivos `TASK_nombre_tarea.MD` espec√≠ficos para cada tarea o funcionalidad mayor).
*   Mantenga los archivos de c√≥digo fuente por debajo de las **300 l√≠neas**. Div√≠dalos en m√≥dulos o componentes m√°s peque√±os cuando sea necesario.
*   Prueba pronto y con frecuencia. Toda funci√≥n o widget nuevo debe incluir pruebas.
*   Escribe documentos y comentarios sobre la marcha. No retrases la documentaci√≥n.

### 2.2. üß† Planificaci√≥n y Gesti√≥n de Tareas

Antes de escribir cualquier c√≥digo para una nueva funcionalidad, es importante conversar con el Ingeniero/programador para planificarla. El alcance general se incluye en `PLANNING.MD` (este documento). Las tareas espec√≠ficas, pasos detallados y el progreso para una funcionalidad o m√≥dulo se detallar√°n en archivos `TASK_nombre_tarea.MD` dedicados. Cada archivo `TASK` se debe crear *antes* de iniciar las tareas correspondientes.

**`PLANNING.MD` (Este Documento)**
*   **Prop√≥sito:** Visi√≥n de alto nivel, arquitectura, restricciones, pila tecnol√≥gica, herramientas y directrices generales para el desarrollo de la aplicaci√≥n completa Agenda Glam. No contiene detalles minuciosos de implementaci√≥n diaria.
*   **Referencia:** Este archivo debe ser consultado al comienzo de cualquier conversaci√≥n nueva relacionada con el proyecto.

**Archivos `TASK_nombre_tarea.MD`**
*   **Prop√≥sito:** Realiza un seguimiento de las tareas actuales, pasos detallados, tareas atrasadas y subtareas para una funcionalidad o m√≥dulo espec√≠fico de Agenda Glam (ej. `TASK_PerfilProveedor.MD`, `TASK_FlujoReservaCliente.MD`). Se crea *antes* de comenzar a trabajar en la tarea.
*   **Incluye:** Lista con vi√±etas de trabajo activo, hitos y cualquier cosa descubierta a mitad del proceso para esa tarea espec√≠fica.
*   **Referencia:** Para la tarea actual, consulta el `TASK_nombre_tarea.MD` correspondiente. Actualiza el archivo `TASK` para marcar pasos como terminados o agregar nuevas subtareas.

### 2.3. ‚öôÔ∏è Directrices de Desarrollo

Estas directrices se aplicar√°n al desarrollo de Agenda Glam para asegurar la calidad, mantenibilidad y escalabilidad del c√≥digo.

#### üèóÔ∏è Arquitectura y Estructura

*   **Adherencia a Clean Architecture:** Mantener una separaci√≥n estricta entre las capas de Presentaci√≥n, Dominio y Datos. La l√≥gica de negocio debe residir en el Dominio y ser independiente de la UI y los detalles de implementaci√≥n de datos.
*   **Modularizaci√≥n:** Organizar el c√≥digo en m√≥dulos cohesivos, preferiblemente agrupados por funcionalidad (feature-first). Cada m√≥dulo debe tener una responsabilidad clara y exponer una interfaz bien definida.
*   **Estructura de Carpetas:** Seguir una estructura de carpetas consistente dentro de cada m√≥dulo (ej. `presentation` (con `bloc`, `pages`, `widgets`), `domain` (con `entities`, `repositories`, `usecases`), `data` (con `datasources`, `models`, `repositories`)).

#### üìè Tama√±o y Complejidad de Archivos

*   **L√≠mite de 300 L√≠neas:** Ning√∫n archivo Dart debe superar las 300 l√≠neas. Refactorizar proactivamente dividiendo clases, widgets o funciones grandes en unidades m√°s peque√±as y enfocadas.
*   **Principio de Responsabilidad √önica (SRP):** Cada clase, widget o funci√≥n debe tener una √∫nica raz√≥n para cambiar. Evitar clases "todopoderosas".

#### ‚ú® Calidad y Buenas Pr√°cticas de Codificaci√≥n

*   **Legibilidad:** Escribir c√≥digo claro, conciso y f√°cil de entender. Usar nombres descriptivos para variables, funciones y clases.
*   **Consistencia:** Seguir las gu√≠as de estilo oficiales de Dart y Flutter (`flutter analyze` debe pasar sin errores/warnings). Utilizar `dart format` regularmente.
*   **Comentarios y Documentaci√≥n:**
    *   Escribir docstrings (`///`) para cada funci√≥n, clase y widget p√∫blico, explicando su prop√≥sito, par√°metros y lo que retorna.
    *   Usar comentarios en l√≠nea (`//`) para explicar l√≥gica compleja o decisiones no obvias (`// Raz√≥n: ...`).
    *   Mantener `README.MD` actualizado con instrucciones de configuraci√≥n y descripci√≥n general.
*   **Inmutabilidad:** Preferir objetos inmutables siempre que sea posible, especialmente para modelos de datos y estados (usar `final` y paquetes como `freezed`).
*   **Manejo de Errores:** Implementar un manejo de errores robusto usando `try-catch`, resultados (Result type) o estados espec√≠ficos en BLoC/Cubit para informar al usuario y evitar crashes.
*   **Evitar "Magic Strings/Numbers":** Definir constantes para valores literales que se repiten o cuyo significado no es obvio.

#### üì¶ Gesti√≥n de Dependencias

*   **Uso Criterioso de Paquetes:** Evaluar cuidadosamente la necesidad y calidad de paquetes externos antes de a√±adirlos. Preferir paquetes bien mantenidos y populares de pub.dev.
*   **Inyecci√≥n de Dependencias:** Utilizar un mecanismo de inyecci√≥n de dependencias (como `get_it` o `provider`) para desacoplar componentes y facilitar las pruebas.

#### üß™ Pruebas y Confiabilidad

*   **Cobertura de Pruebas:** Escribir pruebas unitarias para la l√≥gica de negocio (Dominio) y los componentes de datos, y pruebas de widgets para la UI (Presentaci√≥n).
*   **Pruebas Significativas:** Enfocarse en probar el comportamiento esperado, casos l√≠mite y manejo de errores.
*   **Organizaci√≥n:** Mantener la estructura de la carpeta `test/` reflejando la de `lib/`.

#### ‚úÖ Finalizaci√≥n de Tareas

*   **Actualizaci√≥n de TASK:** Marcar tareas como completadas en el archivo `TASK_nombre_tarea.MD` correspondiente.
*   **Registro de Descubrimientos:** A√±adir nuevas subtareas o TODOs identificados durante el desarrollo al archivo `TASK` relevante.

#### üé® Dise√±o y UX

*   **Consistencia Visual:** Aplicar el tema definido (Secci√≥n 3) de manera uniforme en toda la aplicaci√≥n.
*   **Accesibilidad:** Considerar pautas de accesibilidad (WCAG) en el dise√±o de componentes (tama√±o de fuentes, contraste, navegaci√≥n).
*   **Estilo Espec√≠fico:** Seguir las convenciones de estilo de Flutter/Dart y las espec√≠ficas del proyecto (ej. uso de `freezed`, `flutter_bloc`).

#### üîó Interacciones Externas

*   **Firebase SDKs:** Utilizar los SDKs oficiales de Firebase para Flutter para interactuar con los servicios de Firebase.
*   **Seguridad:** Implementar reglas de seguridad adecuadas en Firestore y seguir las mejores pr√°cticas de Firebase Authentication.

#### üß† Directrices Adicionales

*   **Contexto:** No hacer suposiciones; preguntar si falta contexto.
*   **Bibliotecas:** Usar solo paquetes verificados de pub.dev.
*   **Rutas y Nombres:** Confirmar la existencia de archivos/m√≥dulos antes de referenciarlos.
*   **Modificaci√≥n de C√≥digo:** No eliminar/sobrescribir c√≥digo existente sin indicaci√≥n expl√≠cita o como parte de una tarea definida.
*   **Documentaci√≥n Externa:** Consultar documentaci√≥n actualizada antes de implementar funcionalidades complejas o interactuar con APIs/librer√≠as. **Si es posible, utilizar el MCP `context7` para obtener la documentaci√≥n m√°s reciente.**

### 2.4. üí¨ Enfoque de Desarrollo Inicial

Por el momento, el desarrollo se centrar√° exclusivamente en el **frontend**. Se priorizar√° el dise√±o de la interfaz de usuario (frontend) para cada m√≥dulo o flujo principal. Una vez que el dise√±o de un m√≥dulo est√© claro, esto facilitar√° la definici√≥n precisa de los modelos de datos que necesitar√° el frontend. Los datos para las pruebas del frontend se ingresar√°n manualmente en el c√≥digo (hardcodeados) o se mockear√°n seg√∫n sea necesario. La integraci√≥n con Firebase y la definici√≥n de la estructura de la base de datos se realizar√°n en una fase posterior, una vez que el frontend de los m√≥dulos clave est√© bien definido.

### 2.5. ‚úÖ Prueba Despu√©s de Cada Funci√≥n

Escriba pruebas de widgets despu√©s de cada componente UI que implemente para Agenda Glam, o h√°galo usted mismo. Las pruebas unitarias para l√≥gica de UI (si la hubiera separada) tambi√©n son importantes.

**Mejores pr√°cticas para realizar pruebas en Flutter (enfocadas en frontend inicialmente):**
*   Crea las pruebas en un directorio `test/`.
*   Para pruebas de widgets, utiliza `flutter_test` para verificar que la UI se renderiza correctamente y responde a interacciones.
*   Utiliza datos mock o hardcodeados consistentes con los usados en el desarrollo del widget.

### 2.6. üê≥ Uso de Docker (Opcional)

La utilizaci√≥n de Docker en este proyecto es **opcional**, especialmente en las fases iniciales centradas en el frontend con Flutter y Firebase. Sin embargo, puede considerarse para:

*   **Estandarizaci√≥n del Entorno:** Asegurar que todos los desarrolladores y el sistema de Integraci√≥n Continua (CI) utilicen exactamente las mismas versiones del SDK de Flutter, Dart y otras dependencias del sistema, evitando inconsistencias.
*   **Servicios Auxiliares:** Si en el futuro se desarrollan microservicios propios (ej. para tareas espec√≠ficas de backend no cubiertas por Cloud Functions) o se necesita ejecutar localmente herramientas externas (ej. una base de datos para pruebas), Docker facilitar√≠a su gesti√≥n.
*   **Builds Consistentes:** Crear un entorno aislado y reproducible para generar los artefactos de la aplicaci√≥n (APK/IPA).

**Consideraciones:**
*   A√±ade una capa de complejidad inicial a la configuraci√≥n del entorno de desarrollo.
*   Puede tener un ligero impacto en el rendimiento durante el desarrollo (dependiendo de la configuraci√≥n y el sistema operativo).
*   Se recomienda evaluar su incorporaci√≥n si surgen problemas de inconsistencia entre entornos o si la arquitectura del backend se expande m√°s all√° de Firebase.

## 3. Dise√±o General y Tema de la Aplicaci√≥n (UI/UX)

Se buscar√° un estilo y dise√±o general **minimalista, elegante y con un enfoque est√©tico masculino**, que se aplique consistentemente en toda la aplicaci√≥n. Se priorizar√° una experiencia de usuario intuitiva y clara, considerando las gu√≠as de accesibilidad (WCAG).

### 3.1. Concepto Visual General üé®

*   **Tema:** Oscuro (Dark Theme) predominante.
*   **Paleta Principal:** Azul marino profundo (primario), Dorado/√Åmbar (acento), complementados con tonos de gris azulado oscuro para superficies y blanco/gris claro para textos.
*   **Sensaci√≥n:** Profesional, moderna y sofisticada.

### 3.2. Tipograf√≠a ‚úíÔ∏è

*   **Fuente:** Limpia y legible (ej. Roboto o similar).
*   **Jerarqu√≠a:** Clara distinci√≥n entre t√≠tulos, encabezados y cuerpo de texto mediante tama√±o y peso.

### 3.3. Componentes Clave üß©

Se definir√°n estilos consistentes en el `ThemeData` para elementos comunes como AppBar, botones (ElevatedButton, TextButton, OutlinedButton), campos de texto, tarjetas (Card), di√°logos, etc., siguiendo la paleta y sensaci√≥n general.

### 3.4. Implementaci√≥n Inicial del Tema (Dart)

El `ThemeData` se definir√° en un archivo dedicado (ej. `lib/core/theme/app_theme.dart`) y contendr√° la configuraci√≥n detallada de colores, tipograf√≠a y estilos de widgets. El siguiente es un ejemplo conceptual de la estructura y colores base (la implementaci√≥n detallada se har√° en el archivo de tema espec√≠fico):

```dart
import 'package:flutter/material.dart';

// Paleta de colores base (Valores exactos en el archivo de tema)
const Color _primaryColor = Color(0xFF0A1128);      // Azul marino
const Color _accentColor = Color(0xFFFFC107);       // Dorado/√Åmbar
const Color _backgroundColor = Color(0xFF050A14);   // Fondo oscuro
const Color _surfaceColor = Color(0xFF1E2A3B);      // Superficies oscuras
const Color _textColor = Color(0xFFFFFFFF);         // Texto principal
const Color _secondaryTextColor = Color(0xFFB0B8C1); // Texto secundario
const Color _errorColor = Color(0xFFCF6679);        // Error

/// ThemeData conceptual para Agenda Glam (Implementaci√≥n detallada aparte).
final ThemeData appTheme = ThemeData(
  brightness: Brightness.dark,
  primaryColor: _primaryColor,
  scaffoldBackgroundColor: _backgroundColor,
  colorScheme: const ColorScheme.dark(
    primary: _primaryColor,
    secondary: _accentColor,
    surface: _surfaceColor,
    background: _backgroundColor,
    error: _errorColor,
    onPrimary: _textColor,
    onSecondary: Colors.black, // Texto sobre acento
    onSurface: _textColor,
    onBackground: _textColor,
    onError: _textColor,
  ),
  // ... Definiciones resumidas o placeholders para textTheme, buttonThemes, etc.
  // La configuraci√≥n completa estar√° en el archivo de tema dedicado.
  appBarTheme: const AppBarTheme(
     backgroundColor: _primaryColor,
     centerTitle: true,
     titleTextStyle: TextStyle(fontWeight: FontWeight.bold, color: _textColor, fontSize: 20),
  ),
   // Ejemplo muy b√°sico de bot√≥n elevado
   elevatedButtonTheme: ElevatedButtonThemeData(
     style: ElevatedButton.styleFrom(
       backgroundColor: _accentColor,
       foregroundColor: Colors.black,
       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
     ),
   ),
   // ... etc.
);
```

Este documento de planificaci√≥n general establece las bases para el desarrollo de la aplicaci√≥n completa Agenda Glam, integrando un flujo de trabajo moderno y definiendo claramente el estilo visual y las directrices de codificaci√≥n para maximizar la eficiencia y la calidad del software.